/**
 * Senzing Data Mart Reports REST API
 * This is the Senzing Data Mart Reports API.  This provides endpoints and types for obtaining reports from the data mart.
 *
 * OpenAPI spec version: 2.0.0-beta.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from './http/encoder';

import { Observable }                                        from 'rxjs';

import { SzBoundType } from './http/models/szBoundType';
import { SzCrossSourceMatchCounts } from './http/models/szCrossSourceMatchCounts';
import { SzCrossSourceRelationCounts } from './http/models/szCrossSourceRelationCounts';
import { SzCrossSourceSummary } from './http/models/szCrossSourceSummary';
import { SzEntitiesPage } from './http/models/szEntitiesPage';
import { SzEntityRelationsBreakdown } from './http/models/szEntityRelationsBreakdown';
import { SzEntityRelationsCount } from './http/models/szEntityRelationsCount';
import { SzEntitySizeBreakdown } from './http/models/szEntitySizeBreakdown';
import { SzEntitySizeCount } from './http/models/szEntitySizeCount';
import { SzLoadedStats } from './http/models/szLoadedStats';
import { SzRelationCounts } from './http/models/szRelationCounts';
import { SzRelationsPage } from './http/models/szRelationsPage';
import { SzSourceLoadedStats } from './http/models/szSourceLoadedStats';
import { SzSourceSummary } from './http/models/szSourceSummary';
import { SzSummaryStats } from './http/models/szSummaryStats';

import { BASE_PATH, COLLECTION_FORMATS }                     from './http/variables';
//import { SzStatsConfiguration }                              from './http/configuration';
import { SzDataMartEnvironmentParameters, SzDataMartEnvironment } from './http/sz-datamart-environment';

//@Injectable()
@Injectable({
    providedIn: 'root'
})
export class SzStatisticsService {

    protected basePath = 'http://localhost:8261';
    public defaultHeaders = new HttpHeaders();
    public configuration = new SzDataMartEnvironment();

    constructor(
        protected httpClient: HttpClient, 
        @Optional()@Inject(BASE_PATH) basePath: string, 
        @Optional()@Inject('DATAMART_ENVIRONMENT') configuration: SzDataMartEnvironment) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and an ambiguous-match relationship to an entity having at least one record from the versus data source.
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and an ambiguous-match relationship to an entity having at least one record from the versus data source.  If there are no such entities then this will return a 200 OK response that will have an empty array of entity ID values rather than giving a 404 Not Found response. Further, if there are no entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the entity ID array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAmbiguouslyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getAmbiguouslyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getAmbiguouslyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getAmbiguouslyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getAmbiguouslyCrossMatchedEntityIds.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getAmbiguouslyCrossMatchedEntityIds.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/ambiguous-matches/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the &#x60;SzRelation&#x60; values describing the ambiguous-match relationships between entities having at least one record from the first data source and entities having at least one record from the versus data source.
     * Gets the &#x60;SzRelation&#x60; values describing the ambiguous-match relationships between entities containing at least one record from the first data source and another entity having at least one record from the versus data source. If there are no such relationships then this will return a 200 OK response that will have an empty array of &#x60;SzRelation&#x60; values rather than giving a 404 Not Found response.  Further, if there are no relationships for entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the &#x60;SzRelation&#x60; array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through relationships associated with a statistic.  The value is specified as a bound on the entity ID&#x27;s in the &#x60;SzRelation&#x60; values returned and contains two  entity ID values separated by a colon (e.g.: &#x60;1000:5500&#x60;).  Either of the entity ID&#x27;s can be specified as &#x60;max&#x60; to indicate the maximum legal value of an entity ID (e.g.: &#x60;max:max&#x60; or &#x60;1000:max&#x60;).  If &#x60;max&#x60; is specified by itself it is interpreted as &#x60;max:max&#x60;. The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned &#x60;SzRelation&#x60; values must be canonically greater than the relationship described by the  entity ID values encoded in the bound.  &#x60;SzRelation&#x60; values are ordered  on the first entity ID value and then on the second related entity ID value.  To move to the \&quot;next page\&quot; of relationships specify the encoded value of the entity ID and related ID of the greatest (last) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of relationships specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0:0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max:max&#x60; (indicating the maximum legal value for each of the entity ID&#x27;s).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAmbiguouslyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzRelationsPage>;
    public getAmbiguouslyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzRelationsPage>>;
    public getAmbiguouslyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzRelationsPage>>;
    public getAmbiguouslyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getAmbiguouslyCrossMatchedRelations.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getAmbiguouslyCrossMatchedRelations.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRelationsPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/ambiguous-matches/relations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the cross-summary statistics for ambiguous-match relations between entities having at least one record from one data source and entities having at least one record from another data source (which may be the same), optionally for one or more combination of match key and principle.
     * Gets the cross-summary statistics for ambiguous-match relations between entities having at least one record from a primary data source and entities having at least one record another data source (which may be the same), optionally for one or more combination of match key and principle.  If either of the specified data source codes is not configured then a 404 Not Found response is returned.  *NOTE*:  Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCrossSourceAmbiguousMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'body', reportProgress?: boolean): Observable<SzCrossSourceRelationCounts>;
    public getCrossSourceAmbiguousMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzCrossSourceRelationCounts>>;
    public getCrossSourceAmbiguousMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzCrossSourceRelationCounts>>;
    public getCrossSourceAmbiguousMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getCrossSourceAmbiguousMatchStatistics.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getCrossSourceAmbiguousMatchStatistics.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzCrossSourceRelationCounts>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/ambiguous-matches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the cross-summary statistics for disclosed relations between entities having at least one record from one data source and entities having at least one record from another data source (which may be the same), optionally for one or more combination of match key and principle.
     * Gets the cross-summary statistics for disclosed relations between entities having at least one record from a primary data source and entities having at least one record another data source (which may be the same), optionally for one or more combination of match key and principle.  If either of the specified data source codes is not configured then a 404 Not Found response is returned.  *NOTE*:  Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCrossSourceDisclosedRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'body', reportProgress?: boolean): Observable<SzRelationCounts>;
    public getCrossSourceDisclosedRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzRelationCounts>>;
    public getCrossSourceDisclosedRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzRelationCounts>>;
    public getCrossSourceDisclosedRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getCrossSourceDisclosedRelationStatistics.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getCrossSourceDisclosedRelationStatistics.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRelationCounts>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/disclosed-relations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the cross-summary statistics for matches for entities having at least one record from a primary data source and at least one **other** record from another data source (which may be the same data source),  optionally for one or more combination of match key and principle.
     * Gets the cross-summary statistics for matches between a primary data source and another data source (which may be the same), optionally for one or more combination of match key and principle.  If either of the specified data source codes is not configured then a 404 Not Found response is returned.  *NOTE*:  Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCrossSourceMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'body', reportProgress?: boolean): Observable<SzCrossSourceMatchCounts>;
    public getCrossSourceMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzCrossSourceMatchCounts>>;
    public getCrossSourceMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzCrossSourceMatchCounts>>;
    public getCrossSourceMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getCrossSourceMatchStatistics.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getCrossSourceMatchStatistics.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzCrossSourceMatchCounts>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/matches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the cross-summary statistics for possible-match relations between entities having at least one record from one data source and entities having at least one record from another data source (which may be the same), optionally for one or more combination of match key and principle.
     * Gets the cross-summary statistics for possible-match relations between entities having at least one record from a primary data source and entities having at least one record another data source (which may be the same), optionally for one or more combination of match key and principle.  If either of the specified data source codes is not configured then a 404 Not Found response is returned.  *NOTE*:  Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCrossSourcePossibleMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'body', reportProgress?: boolean): Observable<SzRelationCounts>;
    public getCrossSourcePossibleMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzRelationCounts>>;
    public getCrossSourcePossibleMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzRelationCounts>>;
    public getCrossSourcePossibleMatchStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getCrossSourcePossibleMatchStatistics.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getCrossSourcePossibleMatchStatistics.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRelationCounts>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/possible-matches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the cross-summary statistics for possible relations between entities having at least one record from one data source and entities having at least one record from another data source (which may be the same), optionally for one or more combination of match key and principle.
     * Gets the cross-summary statistics for possible relations between entities having at least one record from a primary data source and entities having at least one record another data source (which may be the same), optionally for one or more combination of match key and principle.  If either of the specified data source codes is not configured then a 404 Not Found response is returned.  *NOTE*:  Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCrossSourcePossibleRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'body', reportProgress?: boolean): Observable<SzRelationCounts>;
    public getCrossSourcePossibleRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzRelationCounts>>;
    public getCrossSourcePossibleRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzRelationCounts>>;
    public getCrossSourcePossibleRelationStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getCrossSourcePossibleRelationStatistics.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getCrossSourcePossibleRelationStatistics.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRelationCounts>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/possible-relations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the cross-summary statistics for one data source versus another data source (which may be the same).
     * Gets the cross-summary statistics for a primary data source versus another data source (which may be the same).  If either of the specified data source codes is not configured then a 404 Not Found response is returned. *NOTE*:  Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCrossSourceSummaryStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'body', reportProgress?: boolean): Observable<SzCrossSourceSummary>;
    public getCrossSourceSummaryStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzCrossSourceSummary>>;
    public getCrossSourceSummaryStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzCrossSourceSummary>>;
    public getCrossSourceSummaryStatistics(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getCrossSourceSummaryStatistics.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getCrossSourceSummaryStatistics.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzCrossSourceSummary>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and a disclosed relationship to an entity having at least one record from the versus data source.
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and a disclosed relationship to an entity having at least one record from the versus data source.  If there are no such entities then this will return a 200 OK response that will have an empty array of  entity ID values rather than giving a 404 Not Found response.  Further, if there are no entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the entity ID array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDisclosedCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getDisclosedCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getDisclosedCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getDisclosedCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getDisclosedCrossRelatedEntityIds.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getDisclosedCrossRelatedEntityIds.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/disclosed-relations/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the &#x60;SzRelation&#x60; values describing the disclosed relationships between entities having at least one record from the first data source and entities having at least one record from the versus data source.
     * Gets the &#x60;SzRelation&#x60; values describing the disclosed relationships between entities containing at least one record from the first data source and another entity having at least one record from the versus data source.  If there are no such relationships then this will return a 200 OK response that will have an empty array of &#x60;SzRelation&#x60; values rather than giving a 404 Not Found response.  Further, if there are no relationships for entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the &#x60;SzRelation&#x60; array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly  delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through relationships associated with a statistic.  The value is specified as a bound on the entity ID&#x27;s in the &#x60;SzRelation&#x60; values returned and contains two  entity ID values separated by a colon (e.g.: &#x60;1000:5500&#x60;).  Either of the entity ID&#x27;s can be specified as &#x60;max&#x60; to indicate the maximum legal value of an entity ID (e.g.: &#x60;max:max&#x60; or &#x60;1000:max&#x60;).  If &#x60;max&#x60; is specified by itself it is interpreted as &#x60;max:max&#x60;. The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned &#x60;SzRelation&#x60; values must be canonically greater than the relationship described by the  entity ID values encoded in the bound.  &#x60;SzRelation&#x60; values are ordered  on the first entity ID value and then on the second related entity ID value.  To move to the \&quot;next page\&quot; of relationships specify the encoded value of the entity ID and related ID of the greatest (last) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of relationships specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0:0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max:max&#x60; (indicating the maximum legal value for each of the entity ID&#x27;s).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDisclosedCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzRelationsPage>;
    public getDisclosedCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzRelationsPage>>;
    public getDisclosedCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzRelationsPage>>;
    public getDisclosedCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getDisclosedCrossRelatedRelations.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getDisclosedCrossRelatedRelations.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRelationsPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/disclosed-relations/relations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and at least one other record from the versus data source.
     * Gets the entity ID&#x27;s of the entities having at least one record from the  first data source and at least one record from the versus data source.  If no entities have at least one record from the first data source and at least one other record from the versus data source then this will return a 200 OK  response that will have an empty array of entity ID&#x27;s rather than giving a 404 Not Found response.  Further, if there are no entity ID&#x27;s for entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the array of ID&#x27;s contained in the response will be empty.  However, if either data source code is not found in the configuration  then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityIdsForCrossMatches(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getEntityIdsForCrossMatches(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getEntityIdsForCrossMatches(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getEntityIdsForCrossMatches(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getEntityIdsForCrossMatches.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getEntityIdsForCrossMatches.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/matches/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity ID&#x27;s of the entities having at least one record from the respective data source.
     * Gets the entity ID&#x27;s of the entities having at least one record from the respective data source.  If no records have been loaded for that data source then this will return a 200 OK response that will have an empty array of entity ID&#x27;s rather than giving a 404 Not Found response.  However, the data  source code in the path is not configured then this will return a 404 Not Found response.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityIdsForDataSource(dataSourceCode: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getEntityIdsForDataSource(dataSourceCode: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getEntityIdsForDataSource(dataSourceCode: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getEntityIdsForDataSource(dataSourceCode: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getEntityIdsForDataSource.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/loaded/data-sources/${encodeURIComponent(String(dataSourceCode))}/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity ID&#x27;s of the entities having the specific number of entity relationships.
     * Gets the entity ID&#x27;s of the entities having the respective number of entity relations.  If no entities have the respective number of entity relations then this will return a 200 OK response that will have an empty array of entity ID&#x27;s rather than giving a 404 Not Found response.  Further, if there are no entity ID&#x27;s for entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the array of ID&#x27;s contained in the response will be empty.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param relationsCount The number of relationships for the entities of interest.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityIdsForEntityRelations(relationsCount: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getEntityIdsForEntityRelations(relationsCount: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getEntityIdsForEntityRelations(relationsCount: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getEntityIdsForEntityRelations(relationsCount: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (relationsCount === null || relationsCount === undefined) {
            throw new Error('Required parameter relationsCount was null or undefined when calling getEntityIdsForEntityRelations.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/relations/${encodeURIComponent(String(relationsCount))}/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity ID&#x27;s of the entities having the specific number of records.
     * Gets the entity ID&#x27;s of the entities having the number of records for the specified entity size.  If no entities have the specified number of records then this will return a 200 OK response that will have an empty array of entity ID&#x27;s rather than giving a 404 Not Found response.  Further, if there are no entity ID&#x27;s for entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the array of ID&#x27;s contained in the response will be empty.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param entitySize The number of records for the entities of interest.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityIdsForEntitySize(entitySize: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getEntityIdsForEntitySize(entitySize: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getEntityIdsForEntitySize(entitySize: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getEntityIdsForEntitySize(entitySize: number, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (entitySize === null || entitySize === undefined) {
            throw new Error('Required parameter entitySize was null or undefined when calling getEntityIdsForEntitySize.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/sizes/${encodeURIComponent(String(entitySize))}/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity counts by the number of entity relations (Entity  Relation Breakdown).
     * Gets the number of entities in the repository for each number of entity relations that exists for those entities.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityRelationsBreakdown(observe?: 'body', reportProgress?: boolean): Observable<SzEntityRelationsBreakdown>;
    public getEntityRelationsBreakdown(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntityRelationsBreakdown>>;
    public getEntityRelationsBreakdown(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntityRelationsBreakdown>>;
    public getEntityRelationsBreakdown(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityRelationsBreakdown>('get',`${this.basePath}/statistics/relations`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the count of entities having the specific number of entity relations.
     * Gets the count of entities having the specific number of entity relations. If there are NO entities having the specified number of entity relations then this will return a 200 OK response with the result indicating a count of zero entities rather than giving a 404 Not Found response.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param relationsCount The number of relationships for the entities of interest.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntityRelationsCount(relationsCount: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntityRelationsCount>;
    public getEntityRelationsCount(relationsCount: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntityRelationsCount>>;
    public getEntityRelationsCount(relationsCount: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntityRelationsCount>>;
    public getEntityRelationsCount(relationsCount: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (relationsCount === null || relationsCount === undefined) {
            throw new Error('Required parameter relationsCount was null or undefined when calling getEntityRelationsCount.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntityRelationsCount>('get',`${this.basePath}/statistics/relations/${encodeURIComponent(String(relationsCount))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity counts by entity size (Entity Size Breakdown).
     * Gets the number of entities in the repository for each entity size  that exists.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntitySizeBreakdown(observe?: 'body', reportProgress?: boolean): Observable<SzEntitySizeBreakdown>;
    public getEntitySizeBreakdown(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitySizeBreakdown>>;
    public getEntitySizeBreakdown(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitySizeBreakdown>>;
    public getEntitySizeBreakdown(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitySizeBreakdown>('get',`${this.basePath}/statistics/sizes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the count of entities having the specific number of records.
     * Gets the count of entities having the specific number of records. If there are NO entities having the specified number of records then this will return a 200 OK response with the result indicating a count of zero entities rather than giving a 404 Not Found response. *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param entitySize The number of records for the entities of interest.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getEntitySizeCount(entitySize: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitySizeCount>;
    public getEntitySizeCount(entitySize: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitySizeCount>>;
    public getEntitySizeCount(entitySize: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitySizeCount>>;
    public getEntitySizeCount(entitySize: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (entitySize === null || entitySize === undefined) {
            throw new Error('Required parameter entitySize was null or undefined when calling getEntitySizeCount.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitySizeCount>('get',`${this.basePath}/statistics/sizes/${encodeURIComponent(String(entitySize))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity and record counts in total and by data source from the data mart.
     * Gets the entity and record counts in total and by data source from the data mart.  *NOTE*: Data mart statistics may be slightly delayed from  the entity repository.
     * @param onlyLoadedSources The optional parameter to specify if only loaded data sources should be considered when iterating over data sources to retrieve statistics. If not specified, this defaults to &#x60;true&#x60;.  Set this explicitly to &#x60;false&#x60; to iterate over all data sources regardless of loaded records in generating the statistics (i.e.: to include the \&quot;zeroes\&quot;).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLoadedStatistics(onlyLoadedSources?: boolean, observe?: 'body', reportProgress?: boolean): Observable<SzLoadedStats>;
    public getLoadedStatistics(onlyLoadedSources?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzLoadedStats>>;
    public getLoadedStatistics(onlyLoadedSources?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzLoadedStats>>;
    public getLoadedStatistics(onlyLoadedSources?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (onlyLoadedSources !== undefined && onlyLoadedSources !== null) {
            queryParameters = queryParameters.set('onlyLoadedSources', <any>onlyLoadedSources);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzLoadedStats>('get',`${this.basePath}/statistics/loaded`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and a possible-match relationship to an entity having at least one record from the versus data source.
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and a possible-match relationship to an entity having at least one record from the versus data source.  If there are no such entities then this will return a 200 OK response that will have an empty array of entity ID values rather than giving a 404 Not Found response. Further, if there are no entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the entity ID array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPossiblyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getPossiblyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getPossiblyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getPossiblyCrossMatchedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getPossiblyCrossMatchedEntityIds.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getPossiblyCrossMatchedEntityIds.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/possible-matches/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the &#x60;SzRelation&#x60; values describing the possible-match relationships between entities having at least one record from the first data source and entities having at least one record from the versus data source.
     * Gets the &#x60;SzRelation&#x60; values describing the possible-match relationships between entities containing at least one record from the first data source and another entity having at least one record from the versus data source. If there are no such relationships then this will return a 200 OK response that will have an empty array of &#x60;SzRelation&#x60; values rather than giving a 404 Not Found response.  Further, if there are no relationships for entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the &#x60;SzRelation&#x60; array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through relationships associated with a statistic.  The value is specified as a bound on the entity ID&#x27;s in the &#x60;SzRelation&#x60; values returned and contains two  entity ID values separated by a colon (e.g.: &#x60;1000:5500&#x60;).  Either of the entity ID&#x27;s can be specified as &#x60;max&#x60; to indicate the maximum legal value of an entity ID (e.g.: &#x60;max:max&#x60; or &#x60;1000:max&#x60;).  If &#x60;max&#x60; is specified by itself it is interpreted as &#x60;max:max&#x60;. The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned &#x60;SzRelation&#x60; values must be canonically greater than the relationship described by the  entity ID values encoded in the bound.  &#x60;SzRelation&#x60; values are ordered  on the first entity ID value and then on the second related entity ID value.  To move to the \&quot;next page\&quot; of relationships specify the encoded value of the entity ID and related ID of the greatest (last) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of relationships specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0:0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max:max&#x60; (indicating the maximum legal value for each of the entity ID&#x27;s).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPossiblyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzRelationsPage>;
    public getPossiblyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzRelationsPage>>;
    public getPossiblyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzRelationsPage>>;
    public getPossiblyCrossMatchedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getPossiblyCrossMatchedRelations.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getPossiblyCrossMatchedRelations.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRelationsPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/possible-matches/relations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and a possible relationship to an entity having at least one record from the versus data source.
     * Gets the entity ID&#x27;s of the entities having at least one record from the first data source and a possible relationship to an entity having at least one record from the versus data source.  If there are no such entities then this will return a 200 OK response that will have an empty array of  entity ID values rather than giving a 404 Not Found response.  Further, if there are no entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the entity ID array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through entity ID&#x27;s associated with a statistic.  The value is specified as a bound on the entity ID values returned and is given as a positive integer number or &#x60;max&#x60; to indicate the maximum legal value of an entity ID.  The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned entity ID values must satisfy the condition that they are strictly greater than the entity ID bound value.  To move to the \&quot;next page\&quot; of entity ID&#x27;s specify the greatest entity ID value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of entity ID&#x27;s specify the least entity ID value on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least entity ID value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max&#x60; (indicating the maximum legal value of an  entity ID).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPossiblyCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzEntitiesPage>;
    public getPossiblyCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzEntitiesPage>>;
    public getPossiblyCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzEntitiesPage>>;
    public getPossiblyCrossRelatedEntityIds(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getPossiblyCrossRelatedEntityIds.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getPossiblyCrossRelatedEntityIds.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzEntitiesPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/possible-relations/entities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the &#x60;SzRelation&#x60; values describing the possible relationships between entities having at least one record from the first data source and entities having at least one record from the versus data source.
     * Gets the &#x60;SzRelation&#x60; values describing the possible relationships between entities containing at least one record from the first data source and another entity having at least one record from the versus data source.  If there are no such relationships then this will return a 200 OK response that will have an empty array of &#x60;SzRelation&#x60; values rather than giving a 404 Not Found response.  Further, if there are no relationships for entities satisfying the bound conditions of the request then similarly a 200 OK response is returned but the &#x60;SzRelation&#x60; array contained in the response will be empty.  However, if either data source code is not found in the configuration then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly  delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param vsDataSourceCode The data source code identifying the data source to which the first data source is compared for the statistics.
     * @param matchKey The optional parameter to specify the match key for which the results are being requested.
     * @param principle The optional parameter to specify a principle for which the results are being requested.
     * @param bound The optional parameter to provide for \&quot;paging\&quot; through relationships associated with a statistic.  The value is specified as a bound on the entity ID&#x27;s in the &#x60;SzRelation&#x60; values returned and contains two  entity ID values separated by a colon (e.g.: &#x60;1000:5500&#x60;).  Either of the entity ID&#x27;s can be specified as &#x60;max&#x60; to indicate the maximum legal value of an entity ID (e.g.: &#x60;max:max&#x60; or &#x60;1000:max&#x60;).  If &#x60;max&#x60; is specified by itself it is interpreted as &#x60;max:max&#x60;. The type of bound is given by the &#x60;boundType&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned &#x60;SzRelation&#x60; values must be canonically greater than the relationship described by the  entity ID values encoded in the bound.  &#x60;SzRelation&#x60; values are ordered  on the first entity ID value and then on the second related entity ID value.  To move to the \&quot;next page\&quot; of relationships specify the encoded value of the entity ID and related ID of the greatest (last) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the \&quot;previous page\&quot; of relationships specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the encoded value of the entity ID and related ID of the least (first) &#x60;SzRelation&#x60; on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value. If not specified, then the default value is taken as &#x60;0:0&#x60; if a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; or &#x60;EXCLUSIVE_LOWER&#x60; is being used, otherwise for a &#x60;boundType&#x60; of &#x60;INCLUSIVE_UPPER&#x60; or &#x60;EXCLUSIVE_UPPER&#x60; it defaults to &#x60;max:max&#x60; (indicating the maximum legal value for each of the entity ID&#x27;s).
     * @param boundType The optional parameter to provide for \&quot;paging\&quot; through results associated with a statistic.  The value is specified as an &#x60;SzBoundType&#x60; and the  bound value is given by the &#x60;bound&#x60; parameter.  For example, by default the &#x60;boundType&#x60; is &#x60;EXCLUSIVE_LOWER&#x60; so the returned values must satisfy the condition that they are strictly greater than the bound value.  To move to the \&quot;next page\&quot; of results specify the greatest result value from the current page and use &#x60;boundType&#x60; of &#x60;EXCLUSIVE_LOWER&#x60;.  To move to the  \&quot;previous page\&quot; of results specify the least result value on the current page and use a &#x60;boundType&#x60; of &#x60;EXCLUSIVE_UPPER&#x60;.  To change the number of results shown on the current page specify the least result value on the current page and specify a &#x60;boundType&#x60; of &#x60;INCLUSIVE_LOWER&#x60; with a new &#x60;pageSize&#x60; value.  Possible values are:   * &#x60;INCLUSIVE_LOWER&#x60; - The bound represents an inclusive lower bound whereby                         values satisfying the bound will be greater-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_LOWER&#x60; - The bound represents an exclusive lower bound whereby                          values satisfying the bound will be strictly greater-than                          the value associated with the bound.   * &#x60;INCLUSIVE_UPPER&#x60; - The bound represents an inclusive upper bound whereby                         values satisfying the bound will be less-than or equal                         to the value associated with the bound.   * &#x60;EXCLUSIVE_UPPER&#x60; - The bound represents an exclusive upper bound whereby                          values satisfying the bound will be strictly less-than                          the value associated with the bound.
     * @param pageSize The optional parameter to limit the number of returned results per page. If not specified then a default value is determined.  If the &#x60;sampleSize&#x60; parameter is provided, then this defaults to 20 times the value of the  &#x60;sampleSize&#x60; parameter.  If the &#x60;sampleSize&#x60; parameter is **not** provided then this simply defaults to &#x60;100&#x60;.  If using the &#x60;sampleSize&#x60; query  parameter and specifying a value for the &#x60;pageSize&#x60; then the &#x60;pageSize&#x60;  should be greater than the &#x60;sampleSize&#x60; by at least an order of magnitude in order tp provide an adequate set of results from which to choose a random sample.  For example, a &#x60;pageSize&#x60; of &#x60;1000&#x60; would be appropriate for a  &#x60;sampleSize&#x60; of &#x60;50&#x60; or &#x60;100&#x60;.
     * @param sampleSize The optional parameter to extract a sample of this size from the page of  results being returned.  When using this parameter the caller should typically use a much larger page size (e.g.: 1000 or 5000) and pull a  random sample (e.g.: 50 to 100).  To obtain another sample with no overlap with the previous sample(s), simply change the &#x60;bound&#x60; and &#x60;boundType&#x60; parameter so the eligible results for the page are outside the range of the previous sample(s).  The value of this parameter should be less-than the specified &#x60;pageSize&#x60; query parameter (typically by at least an order of magnitude).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPossiblyCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'body', reportProgress?: boolean): Observable<SzRelationsPage>;
    public getPossiblyCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzRelationsPage>>;
    public getPossiblyCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzRelationsPage>>;
    public getPossiblyCrossRelatedRelations(dataSourceCode: string, vsDataSourceCode: string, matchKey?: string, principle?: string, bound?: string, boundType?: SzBoundType, pageSize?: number, sampleSize?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getPossiblyCrossRelatedRelations.');
        }

        if (vsDataSourceCode === null || vsDataSourceCode === undefined) {
            throw new Error('Required parameter vsDataSourceCode was null or undefined when calling getPossiblyCrossRelatedRelations.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (bound !== undefined && bound !== null) {
            queryParameters = queryParameters.set('bound', <any>bound);
        }
        if (boundType !== undefined && boundType !== null) {
            queryParameters = queryParameters.set('boundType', <any>boundType);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (sampleSize !== undefined && sampleSize !== null) {
            queryParameters = queryParameters.set('sampleSize', <any>sampleSize);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzRelationsPage>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}/vs/${encodeURIComponent(String(vsDataSourceCode))}/possible-relations/relations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the entity and record counts for a specific data source from the data mart.
     * Gets the entity and record counts for a specific data source from the data mart.  If no records have been loaded for the data source then  this returns a 200 OK response with counts of zero.  However, if the data source is not recognized then a 404 Not Found response is returned. *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSourceLoadedStatistics(dataSourceCode: string, observe?: 'body', reportProgress?: boolean): Observable<SzSourceLoadedStats>;
    public getSourceLoadedStatistics(dataSourceCode: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzSourceLoadedStats>>;
    public getSourceLoadedStatistics(dataSourceCode: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzSourceLoadedStats>>;
    public getSourceLoadedStatistics(dataSourceCode: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getSourceLoadedStatistics.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzSourceLoadedStats>('get',`${this.basePath}/statistics/loaded/data-sources/${encodeURIComponent(String(dataSourceCode))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the summary statistics for a specific data source versus every other data source including itself.
     * Gets the summary statistics for a specific data source versus every other data source including itself.  If the specified data source code is not configured then a 404 Not Found response is returned.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param dataSourceCode The data source code identifying the data source.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param onlyLoadedSources The optional parameter to specify if only loaded data sources should be considered when iterating over data sources to retrieve statistics. If not specified, this defaults to &#x60;true&#x60;.  Set this explicitly to &#x60;false&#x60; to iterate over all data sources regardless of loaded records in generating the statistics (i.e.: to include the \&quot;zeroes\&quot;).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSourceSummaryStatistics(dataSourceCode: string, matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe?: 'body', reportProgress?: boolean): Observable<SzSourceSummary>;
    public getSourceSummaryStatistics(dataSourceCode: string, matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzSourceSummary>>;
    public getSourceSummaryStatistics(dataSourceCode: string, matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzSourceSummary>>;
    public getSourceSummaryStatistics(dataSourceCode: string, matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling getSourceSummaryStatistics.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (onlyLoadedSources !== undefined && onlyLoadedSources !== null) {
            queryParameters = queryParameters.set('onlyLoadedSources', <any>onlyLoadedSources);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzSourceSummary>('get',`${this.basePath}/statistics/summary/data-sources/${encodeURIComponent(String(dataSourceCode))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets the summary statistics for each data source versus every other  data source including itself.
     * Gets the summary statistics for each data source versus every other data source including itself.  *NOTE*: Data mart statistics may be slightly delayed from the entity repository.
     * @param matchKey The optional parameter to specify a match key for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all match keys should be returned.
     * @param principle The optional parameter to specify a principle for which the statistics are being requested.  Specify an asterisk (&#x60;*&#x60;) if the statistics for  all principles should be returned.
     * @param onlyLoadedSources The optional parameter to specify if only loaded data sources should be considered when iterating over data sources to retrieve statistics. If not specified, this defaults to &#x60;true&#x60;.  Set this explicitly to &#x60;false&#x60; to iterate over all data sources regardless of loaded records in generating the statistics (i.e.: to include the \&quot;zeroes\&quot;).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSummaryStatistics(matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe?: 'body', reportProgress?: boolean): Observable<SzSummaryStats>;
    public getSummaryStatistics(matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzSummaryStats>>;
    public getSummaryStatistics(matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzSummaryStats>>;
    public getSummaryStatistics(matchKey?: string, principle?: string, onlyLoadedSources?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (matchKey !== undefined && matchKey !== null) {
            queryParameters = queryParameters.set('matchKey', <any>matchKey);
        }
        if (principle !== undefined && principle !== null) {
            queryParameters = queryParameters.set('principle', <any>principle);
        }
        if (onlyLoadedSources !== undefined && onlyLoadedSources !== null) {
            queryParameters = queryParameters.set('onlyLoadedSources', <any>onlyLoadedSources);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzSummaryStats>('get',`${this.basePath}/statistics/summary`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
